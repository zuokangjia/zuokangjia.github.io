<!DOCTYPE html>
<html lang="zh-Hans" color-mode="light">

  <head><!-- hexo injector head_begin start -->
    <script>
      window.LivePhotoConfig = {"enable":true,"autoplay":true,"hover_to_play":true,"click_to_play":true,"lazy_load":true,"threshold":0.8,"badge":true,"badge_text":"Live","badge_position":"bottom-left","loading_animation":true,"preload":"auto","keep_observing":false,"hover_delay":300,"weixin_disable_autoplay":true};
    </script>
  <style>/* Live Photo 容器 */
.live-photo-container {
  position: relative;
  border-radius: 12px;
  margin: 20px auto;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  max-width: 100%;
  display: table; /* 使用 table 使容器宽度自适应图片内容 */
  width: auto;
}

.live-photo-container:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
}

/* 静态封面图 */
.live-photo-static {
  width: auto; /* 保持图片原始比例和宽度 */
  max-width: 100%;
  display: block;
  border-radius: 8px;
  transition: opacity 0.3s;
}

/* 视频图层 */
.live-photo-video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  border-radius: 8px;
  transition: opacity 0.3s;
}

.live-photo-video.playing {
  opacity: 1;
}

/* Live 徽章 */
.live-badge {
  position: absolute;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
  -webkit-backdrop-filter: blur(10px);
  backdrop-filter: blur(10px);
  z-index: 10;
}

.live-badge::before {
  content: '';
  width: 8px;
  height: 8px;
  background: #ff2e4d;
  border-radius: 50%;
  display: inline-block;
}

/* 徽章位置 */
.live-badge.bottom-left {
  bottom: 12px;
  left: 12px;
}

.live-badge.bottom-right {
  bottom: 12px;
  right: 12px;
}

.live-badge.top-left {
  top: 12px;
  left: 12px;
}

.live-badge.top-right {
  top: 12px;
  right: 12px;
}

/* 加载动画 */
.live-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border: 3px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: #ff2e4d;
  animation: livephoto-spin 1s ease-in-out infinite;
  display: none;
  z-index: 1;
}

@keyframes livephoto-spin {
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* 图片说明 */
.live-caption {
  text-align: center;
  margin-top: 8px;
  font-size: 14px;
  color: #666;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .live-photo-container {
    border-radius: 8px;
    margin: 16px auto;
  }

  .live-badge {
    font-size: 11px;
    padding: 3px 6px;
  }
}

/* 多图布局支持 */
.image-grid, .image-grid-grid, .image-float-container {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin: 20px 0;
  justify-content: center;
}

.image-grid .live-photo-container,
.image-grid-grid .live-photo-container,
.image-float-container .live-photo-container {
  margin: 0;
  display: inline-block; /* 在网格中保持行内块属性 */
}

/* 确保非网格状态下居中 */
.live-photo-container:not(.image-grid):not(.image-grid-grid):not(.image-float-container) {
  margin: 20px auto;
}
</style><!-- hexo injector head_begin end -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Kangjia" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  <meta name="description" content="zzz" />
  
  
  
  <title>
    
      Leetcode刷题记录 
      
      
      |
    
     BlueSKyzzz
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">BlueSkyzzz</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Leetcode刷题记录</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2026-01-04 19:35:36
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/algorithm/" title="algorithm">
                    #algorithm
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>遍历每一个柱子，向左向右找到最高的柱子，然后取左右最高柱子中较小的那个，减去当前柱子的高度，就是当前柱子能接的雨水。</p>
<p>优化点：找最高柱子的过程可以优化，用空间换时间。</p>
<p>如果用数组来存储这个数据，需要O(n)的空间,但是观察可以发现，每个位置的数据只用了一次，而不同位置的数字之间也存在着某种联系。</p>
<p>所以可以使用双指针来优化，一个指向左边最高的柱子，一个指向右边最高的柱子，然后向中间移动，直到两指针相遇，此时两指针所指的柱子就是最高的柱子。在这个移动的过程中，边移动边计算当前位置能接的雨水。这样可以将空间复杂度降低到O(1)。</p>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><p>一个链表，交换相邻的两个节点，直到没有相邻的两个节点可以交换。</p>
<p>思路：从头到尾，每两个为一组（不足两个的不用交换），步长为2，遍历链表，使用临时变量保存当前节点的下一个节点，然后交换当前节点和下一个节点的指针，然后移动到下一个节点的下一个节点。</p>
<p>要注意使用last 来更新最后一个交换的节点，否则会出现链表断裂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur!=<span class="literal">null</span> &amp;&amp; cur.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first!=<span class="number">1</span>)last.next=cur.next;</span><br><span class="line">            <span class="keyword">else</span> first=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//记录并更新上一个</span></span><br><span class="line">            last = cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调整指针</span></span><br><span class="line">            temp=cur.next.next;</span><br><span class="line">            cur.next.next = cur;</span><br><span class="line">            cur.next=temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里要注意的是，链表已经交换了，cur位于后位，所以要更新cur到cur的下一个节点，而不是最开始的last.next.next。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//不过这里形式上是下一个，要明白这是下一个的下一个。</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指针交换如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zuokangjia/Picture/main/2025/03/upgit_20250312_1741774693.png" alt="指针交换"><span class="image-caption">指针交换</span></p>
<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a>51. N 皇后</h2><p>N皇后，不能再经典的回溯题，逻辑很好理解，即使用回溯的方式枚举所有的可能，然后判断可行性，得到所有的可行解。<br>不过这个输出格式实在是想吐槽，莫名其妙的格式（不过应该是我对字符串以及组织不熟悉）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]==<span class="number">0</span> &amp;&amp; x[i+num]==<span class="number">0</span> &amp;&amp; xx[i-num+n-<span class="number">1</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">                c[i]=<span class="number">1</span>;             <span class="comment">//column</span></span><br><span class="line">                x[i+num]=<span class="number">1</span>;         <span class="comment">//left diagonal</span></span><br><span class="line">                xx[i-num+n-<span class="number">1</span>]=<span class="number">1</span>;    <span class="comment">//right diagonal</span></span><br><span class="line">                ans[num]=i;</span><br><span class="line">                f(ans,num+<span class="number">1</span>);</span><br><span class="line">                c[i]=<span class="number">0</span>;</span><br><span class="line">                x[i+num]=<span class="number">0</span>;</span><br><span class="line">                xx[i-num+n-<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>题目中要求的 字符串格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span></span><br><span class="line"><span class="keyword">if</span>(num==n)&#123;</span><br><span class="line">            List&lt;String&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="type">char</span>[] row = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">                Arrays.fill(row, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                row[ans[i]] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                temp.add(<span class="keyword">new</span> <span class="title class_">String</span>(row));</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><h3 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="1.中序遍历"></a>1.中序遍历</h3><p><strong>排序二叉树的中序遍历是升序的。</strong></p>
<p>所以可以将中序遍历输出到一个数组，再检查数组是否是升序的即可。<br>可以对其进行空间优化。遍历中进行判断，记录上一个节点的值，如果当前节点的值小于等于上一个节点的值，则不是二叉搜索树。</p>
<p>但是第一个点不是很好判断，如果设置一个初始值<code>last=Long.MIN_VALUE</code>,  可以解决这个问题。<br>也可以用一个组合节点来判断，如果是第一个就跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//Long.MIN_VALUE;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">isbigger</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">l</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(first)&#123;first = <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> isbigger = isbigger &amp;&amp; root.val &gt; last;</span><br><span class="line">        <span class="comment">//System.out.println(root.val+&quot; &quot;+isbigger);</span></span><br><span class="line">        last = root.val;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isbigger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-递归检查"><a href="#2-递归检查" class="headerlink" title="2.递归检查"></a>2.递归检查</h3><p>递归检查，设置上下限，递归检查左右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        注意这里的上下限，如果是Integer.MIN_VALUE，则会导致死循环。</span></span><br><span class="line"><span class="string">        所以这里设置成null，表示无穷小。</span></span><br><span class="line"><span class="string">        其实我没有验证过，但是应该是可以的，思路是一样的。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> check(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode root, Integer lower, Integer upper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lower!= <span class="literal">null</span> &amp;&amp; root.val &lt;= lower) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(upper!= <span class="literal">null</span> &amp;&amp; root.val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left, lower, root.val) &amp;&amp; check(root.right, root.val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><p>二叉树的遍历方式有很多种，深度优先搜索，广度优先搜索，层序遍历。深搜还可以分为前序遍历，中序遍历，后序遍历。广搜可以分为层序遍历，宽度遍历。</p>
<p>层序遍历就是先把根节点放入队列，然后依次弹出队列中的节点，并将其左右子节点放入队列，直到队列为空。</p>
<p>层次遍历和广搜的区别是，层序遍历是按层次遍历，广搜是按宽度遍历。<br>尽管都是使用队列，但是层次遍历会在每一层加入队列后停下一个间隔，记录一下这个层的宽度（通常是队列的大小），而广搜则是一次性将所有节点都加入队列，然后按宽度遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt;list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">Size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Size;i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span>queue.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="literal">null</span>)queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="literal">null</span>)queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>也是经典题，如果能明白中序遍历和前序遍历的特点，那么这道题就很简单。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>很显然，中序遍历的左右子树是由根节点分开的。而前序遍历的第一个节点就是根节点。前序遍历的第二个节点到倒数第二个节点就是左子树，倒数第二个节点到最后一个节点就是右子树。</p>
<p>所以，我们可以先找到根节点在中序遍历中的位置，然后递归地构造左右子树。<br>在中序遍历中寻找根节点的算法可以使用MAP，也可以使用线性查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> work(<span class="number">0</span>,preorder.length,<span class="number">0</span>,preorder.length,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">work</span><span class="params">(<span class="type">int</span> pl,<span class="type">int</span> pr,<span class="type">int</span> il,<span class="type">int</span> ir,<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pl&gt;=pr)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[pl];</span><br><span class="line">        <span class="comment">//这里可以使用map对索引查找进行优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=il;i&lt;ir;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==val)&#123;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                <span class="type">int</span> <span class="variable">leftsize</span> <span class="operator">=</span> i - il;</span><br><span class="line">                <span class="comment">//rightsize = ir - i;</span></span><br><span class="line">                <span class="comment">//System.out.println(pl+1+&quot; &quot;+(pl+1+leftsize)+&quot; &quot;+il+&quot; &quot;+i);</span></span><br><span class="line">                <span class="comment">//System.out.println(pl+1+leftsize+&quot; &quot;+(pr)+&quot; &quot;+(i+1)+&quot; &quot;+ir);</span></span><br><span class="line">                res.left = work(pl+<span class="number">1</span>,pl+<span class="number">1</span>+leftsize,il,i,preorder,inorder);</span><br><span class="line">                res.right = work(pl+<span class="number">1</span>+leftsize,pr,i+<span class="number">1</span>,ir,preorder,inorder);   </span><br><span class="line">                <span class="comment">//if(res.left==null) System.out.println(&quot;NULL&quot;);</span></span><br><span class="line">                <span class="comment">//else System.out.println(res.left.val+&quot; &quot;+res.right.val);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>没看看懂这一块</p>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><h3 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1.堆排序"></a>1.堆排序</h3><p>本来我看那个数据规模，K次找最大，复杂度就是O(K * N),10^9应该能过的，结果没有，就是复杂度还不够。</p>
<p>标签里有堆排序，所以用堆排序来做。（很长时间没看堆排序，所以有些生疏，在更新堆的时候搞错了边界，需要注意）</p>
<p>堆排序的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] heap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100005</span>];</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">            ans = deleteTop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        heap[cur]=num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag &amp;&amp; tmp/<span class="number">2</span>&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(heap[tmp]&gt;heap[tmp/<span class="number">2</span>]) &#123;</span><br><span class="line">                swap(tmp,tmp/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteTop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> heap[<span class="number">1</span>];</span><br><span class="line">        heap[<span class="number">1</span>] = heap[cur-<span class="number">1</span>];</span><br><span class="line">        cur--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp*<span class="number">2</span>&lt;cur &amp;&amp; (heap[tmp]&lt;heap[tmp*<span class="number">2</span>] || heap[tmp]&lt;heap[tmp*<span class="number">2</span>+<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span>(heap[tmp*<span class="number">2</span>]&gt;heap[tmp*<span class="number">2</span>+<span class="number">1</span>]) &#123;</span><br><span class="line">               swap(tmp,tmp*<span class="number">2</span>);</span><br><span class="line">                tmp = tmp*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(tmp,tmp*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">                tmp = tmp*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>heap[i];</span><br><span class="line">        heap[i]=heap[j];</span><br><span class="line">        heap[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆排序其实很简单，只有两个操作，插入和删除。</p>
<ul>
<li>插入就往堆的末尾插入一个元素，然后从堆的最后向上更新堆。</li>
<li>删除就是删除堆顶元素，将最后一个元素放到堆顶，然后从堆顶向下更新堆。</li>
</ul>
<p><strong>堆是一棵顺序存储的完全二叉树。</strong></p>
<p>其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆为小根堆。反之，每个结点的关键字都不小于其孩子结点的关键字，这样的堆为大根堆。</p>
<p>实现起来很简单，就是维护<strong>一个数组</strong>和<strong>数据个数</strong>，然后每次插入和删除的时候，都更新堆。（更新的时候好像还可以使用递归的写法，以后再研究）</p>
<p>堆排序的时间复杂度是O(NlogN)，N是数组的长度，logN是堆的高度。<br>对于本题，时间复杂度是O(NlogN),非常接近于O(N)。</p>
<h3 id="2-快速选择算法"><a href="#2-快速选择算法" class="headerlink" title="2.快速选择算法"></a>2.快速选择算法</h3><p>快排每次都选择一个元素作为基准，然后将比基准小的放左边，比基准大的放右边。按这个基准分割，左边的元素都比基准小，右边的元素都比基准大。这个基准的位置就不会变了，即最终的位置。在排序过程中，只要这个位置是第K个，就说明这个就是第K大的元素。</p>
<p>[TODO]</p>
<p>具体代码还没写，先放这。</p>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><blockquote>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1：<br>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最简单的思路就是枚举所有的平方数的组合，查看是否和<code>n</code>相等，寻找最小的组合；<br>但这样会很差，很多重复的判断，很多不必要的判断。<br>显然，可以察觉到，尽量用大的平方数进行相加，能减少数量。</p>
<p>所以在使用搜索的方式时，需要从大数开始枚举，通过回溯的方式，完成对组合的枚举（然后再加一些剪枝优化）</p>
<p>但是，很明显有重复搜索（<strong>重叠子问题</strong>），所以可以进行记忆化搜索。<br>同时发现，<code>f[n]</code>只与<code>f[m] (m&lt;n)</code>有关，满足<strong>最优子结构</strong>。<br>可以用动态和规划，直接进行迭代。(实际上这就是一个<strong>完全背包问题</strong>)</p>
<h3 id="1-直接搜索（ai）"><a href="#1-直接搜索（ai）" class="headerlink" title="1.直接搜索（ai）"></a>1.直接搜索（ai）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量记录最小数量，初始为最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化最小数量为极大值</span></span><br><span class="line">        minCount = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤1：收集所有不超过n的平方数（从大到小，优先选大的减少递归）</span></span><br><span class="line">        List&lt;Integer&gt; squares = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(n); i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            squares.add(i * i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤2：回溯（起始索引0，剩余值n，已选数量0）</span></span><br><span class="line">        backtrack(squares, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯核心方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> squares 所有不超过n的平方数（从大到小）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start   当前枚举的起始索引（避免重复组合）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remain  剩余需要凑的数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count   已选的平方数数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; squares, <span class="type">int</span> start, <span class="type">int</span> remain, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝1：当前数量已≥已知最小值，无需继续递归（不可能更优）</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= minCount) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 终止条件：剩余值为0，找到有效组合，更新最小值</span></span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">            minCount = count;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 枚举平方数（从start开始，避免重复组合）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; squares.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">square</span> <span class="operator">=</span> squares.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 剪枝2：当前平方数超过剩余值，跳过（选了会超，无意义）</span></span><br><span class="line">            <span class="keyword">if</span> (square &gt; remain) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 选择当前平方数：递归（剩余值-平方数，数量+1）</span></span><br><span class="line">            backtrack(squares, i, remain - square, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2.记忆化搜索"></a>2.记忆化搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] memo; <span class="comment">// 备忘录：memo[remain] = 凑出remain的最少数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录：-1表示未计算</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 边界：0需要0个平方数</span></span><br><span class="line">        <span class="comment">// 收集平方数</span></span><br><span class="line">        List&lt;Integer&gt; squares = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i*i &lt;= n; i++) squares.add(i*i);</span><br><span class="line">        <span class="comment">// 记忆化递归</span></span><br><span class="line">        <span class="keyword">return</span> dfs(squares, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归函数：返回凑出remain的最少数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; squares, <span class="type">int</span> remain)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[remain] != -<span class="number">1</span>) <span class="keyword">return</span> memo[remain]; <span class="comment">// 直接返回已计算的解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minCount</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : squares) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; remain) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 递归计算子问题：remain-s的最少数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">subCount</span> <span class="operator">=</span> dfs(squares, remain - s);</span><br><span class="line">            <span class="keyword">if</span> (subCount != Integer.MAX_VALUE) &#123;</span><br><span class="line">                minCount = Math.min(minCount, subCount + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[remain] = minCount; <span class="comment">// 记录到备忘录</span></span><br><span class="line">        <span class="keyword">return</span> minCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：默认极大值（表示初始无法凑出）</span></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 基础子问题</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有平方数</span></span><br><span class="line">        List&lt;Integer&gt; squares = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i*i &lt;= n; i++) squares.add(i*i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从底向上计算每个j的最优解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> s : squares) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= s) &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - s] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这套代码的循环不太一样。具体见‘背包’中的完全背包问题</p>
<h3 id="4-数学分析"><a href="#4-数学分析" class="headerlink" title="4.数学分析"></a>4.数学分析</h3><p><del>奇技淫巧</del><br>根据「四平方和定理」：<br>任何自然数都可以表示为最多 4 个完全平方数的和。<br>如果 n 是 4^k*(8m+7) 形式，则必须用 4 个平方数。<br>否则，判断是否能由 1 个、2 个平方数组成，剩下的都是 3 个。<br>这种方法时间复杂度为 O(√n)，远优于 DP 的 O(n√n)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 判断是否是完全平方数（1个）</span></span><br><span class="line">        <span class="keyword">if</span> (isPerfectSquare(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 判断是否是4^k*(8m+7)形式（必须4个）</span></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 判断是否能由2个平方数组成</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxBase</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= maxBase; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPerfectSquare(n - i * i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 剩下的都是3个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助函数：判断是否是完全平方数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sqrt</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(x);</span><br><span class="line">        <span class="keyword">return</span> sqrt * sqrt == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种完全背包问题，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322.零钱兑换</a>也是相似的解法</p>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41 缺失的第一个正数"></a>41 缺失的第一个正数</h2><blockquote>
<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>输入：nums &#x3D; [1,2,0]<br>输出：3</p>
<p>输入：nums &#x3D; [3,4,-1,1]<br>输出：2</p>
<p>输入：nums &#x3D; [7,8,9,11,12]<br>输出：1</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>朴素浅显的思路是，遍历数组，依次将每个数加入<code>HashSet</code>。完成后，遍历<code>HashSet</code>，找到最小的正整数。<br>时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(n)</code>。</p>
</li>
<li><p>但这样会有空间上的浪费，浪费一个<code>hashset</code>的空间。这样就可以自己依赖原本的数组，来记录每个数是否出现过，自己实现一个<code>hashset</code>。但是数组是覆盖整个int范围的，没办法进行特殊标记。<br>但题目要求的不是最小的数，而是最小的正整数。所以可以先过滤一遍，将所有负数和0都过滤掉，变为超出长度的数值。<br>然后再遍历数组，记录每个数是否出现，将对应下标的数字变为负数，表示已经出现过。<br>最后再遍历数组，找到第一个正数，该数的下标就是最小的正整数。<br>（提醒，由于0不考虑在内，所以下标映射要减一）</p>
</li>
</ol>
<p>标签： <code>哈希表</code>  <code>数组</code>  <code>负数</code>  <code>最小正整数</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//规定了正数，就是突破点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span>)nums[i]=MAX+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将负数转化成超出范围的正数，这里设定为   长度+1；这样就全都是正数了，可以用负数对下标进行标记了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.abs(nums[i]);</span><br><span class="line">            <span class="comment">// 负数变为正数，再判断范围，这样可以圈定1~n范围的数</span></span><br><span class="line">            <span class="comment">// 出现过的数标记为负数（如果原本就是负数，说明已经被标记了）</span></span><br><span class="line">            <span class="keyword">if</span>(temp &lt;= MAX) nums[temp-<span class="number">1</span>]= - Math.abs(nums[temp-<span class="number">1</span>]);   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//都是负数，就说明1~n都有，就返回n+1</span></span><br><span class="line">        <span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a>76. 最小覆盖子串</h2><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：<br>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”</p>
<p>示例 2：<br>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”</p>
<p>示例 3:<br>输入：s &#x3D; “a”, t &#x3D; “aa”<br>输出：”aa”</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>暴力法：枚举子串，判断是否包含t的所有字符，时间复杂度是O(n^3)，空间复杂度是O(1)。</p>
<p>滑动窗口法：一种更简单、剪枝后的暴力法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=76 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [76] 最小覆盖子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h2><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2</p>
<p>示例 2：</p>
<p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>示例 3：</p>
<p>输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]<br>输出：0.00000</p>
</blockquote>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><strong>处理边界情况</strong>的地方非常多，需要考虑到各种边界情况！<br>多看、多验证、多思考！</p>
<h3 id="1-二分-kth元素"><a href="#1-二分-kth元素" class="headerlink" title="1.二分 + kth元素"></a>1.二分 + kth元素</h3><p>找第 k 小的数，可以用二分法，时间复杂度是 O(log(min(m,n)))。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length, n = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> m + n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数：找第 (total+1)/2 小的数</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, (total + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数：找第 total/2 和 total/2+1 小的数的平均值</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">left</span> <span class="operator">=</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">right</span> <span class="operator">=</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找两个有序数组中第k小的数（k从1开始）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果nums1已经用完，直接从nums2中取</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums1.length) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果nums2已经用完，直接从nums1中取</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums2.length) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果k==1，返回两个数组当前元素的最小值</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到两个数组中的第k/2个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid1</span> <span class="operator">=</span> (i + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? </span><br><span class="line">                   nums1[i + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid2</span> <span class="operator">=</span> (j + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? </span><br><span class="line">                   nums2[j + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较并舍弃较小的那一半</span></span><br><span class="line">        <span class="keyword">if</span> (mid1 &lt; mid2) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i + k/<span class="number">2</span>, nums2, j, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, j + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-分割数组"><a href="#2-分割数组" class="headerlink" title="2.分割数组"></a>2.分割数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保nums1是较短的数组，简化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length, n = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLeft</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 分割线左边应该有多少个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在nums1中二分查找合适的分割线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// i: nums1中分割线右边的第一个元素下标</span></span><br><span class="line">            <span class="comment">// j: nums2中分割线右边的第一个元素下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 分割线需要左移</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理边界情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1LeftMax</span> <span class="operator">=</span> (i == <span class="number">0</span>) ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1RightMin</span> <span class="operator">=</span> (i == m) ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LeftMax</span> <span class="operator">=</span> (j == <span class="number">0</span>) ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2RightMin</span> <span class="operator">=</span> (j == n) ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数：中位数在分割线左边</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数：中位数是左右两边的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (Math.max(nums1LeftMax, nums2LeftMax) + </span><br><span class="line">                    Math.min(nums1RightMin, nums2RightMin)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2025/03/04/computer-network-Linkde-layer/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2026-01-04 19:35:36
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/algorithm/" title="algorithm">
                        #algorithm
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/04/04/python-101/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N-%E7%9A%87%E5%90%8E"><span class="toc-text">51. N 皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">1.中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E6%A3%80%E6%9F%A5"><span class="toc-text">2.递归检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">215. 数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">1.堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-text">2.快速选择算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">279. 完全平方数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%90%9C%E7%B4%A2%EF%BC%88ai%EF%BC%89"><span class="toc-text">1.直接搜索（ai）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">2.记忆化搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">3.动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90"><span class="toc-text">4.数学分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-text">41 缺失的第一个正数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-text">76. 最小覆盖子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">4. 寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86-kth%E5%85%83%E7%B4%A0"><span class="toc-text">1.二分 + kth元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84"><span class="toc-text">2.分割数组</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/zuokangjia">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2026 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95 + '&url=' + https%3A%2F%2Fzuokangjia.github.io%2F2025%2F03%2F12%2Falgorithm-recording%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://zuokangjia.github.io/2025/03/12/algorithm-recording/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  <!-- hexo injector body_end start --><script>// LivePhoto类，管理单个Live Photo的行为
class LivePhoto {
  constructor(container, config) {
    this.container = container;
    this.staticImage = container.querySelector(".live-photo-static");
    this.video = container.querySelector(".live-photo-video");
    this.config = config;
    this.hasAutoPlayed = false;
    this.isPlaying = false;
    this.hoverTimeout = null;
    this.isWeixin = this.detectWeixinBrowser();

    // 在微信环境中调整配置
    if (this.isWeixin && this.config.weixin_disable_autoplay) {
      this.config.autoplay = false;

      // 修改微信环境下的badge
      this.modifyWeixinBadge();
    }

    // 绑定事件
    this.bindEvents();
  }

  // 检测微信浏览器
  detectWeixinBrowser() {
    const ua = navigator.userAgent.toLowerCase();
    return ua.includes("micromessenger");
  }

  // 修改微信环境下的badge
  modifyWeixinBadge() {
    let badge = this.container.querySelector(".live-badge");

    // 如果没有badge，创建一个
    if (!badge && this.config.badge) {
      badge = document.createElement("div");
      badge.className = `live-badge ${
        this.config.badge_position || "bottom-left"
      }`;
      this.container.appendChild(badge);
    }

    // 修改badge内容和样式
    if (badge) {
      if(!this.config.badge_text) {
        badge.innerHTML = "点击播放";
      } else{
        badge.innerHTML = this.config.badge_text + " | 点击播放";
      }
    }
  }

  // 绑定事件
  bindEvents() {
    // 桌面端：鼠标悬停播放
    if (this.config.hover_to_play) {
      this.container.addEventListener("mouseenter", () =>
        this.handleHoverStart()
      );
      this.container.addEventListener("mouseleave", () =>
        this.handleHoverEnd()
      );
    }

    // 点击事件 - 在微信环境中这是主要的交互方式
    if (this.config.click_to_play) {
      this.container.addEventListener("click", (e) => {
        this.play();
      });
    }

    // 监听视频结束事件
    this.video.addEventListener("ended", () => this.stop());

    // 监听视频加载事件
    this.video.addEventListener("loadstart", () => this.showLoading());
    this.video.addEventListener("canplay", () => this.hideLoading());
    this.video.addEventListener("error", () => this.hideLoading());
  }

  // 处理悬停开始
  handleHoverStart() {
    // 清除之前的超时
    if (this.hoverTimeout) clearTimeout(this.hoverTimeout);

    // 设置延迟播放
    this.hoverTimeout = setTimeout(() => {
      this.play();
    }, this.config.hover_delay || 300);
  }

  // 处理悬停结束
  handleHoverEnd() {
    // 清除悬停超时
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }

    // 如果视频正在播放，不停止（让它播放完）
  }

  // 显示加载指示器
  showLoading() {
    let loadingEl = this.container.querySelector(".live-loading");
    if (!loadingEl && this.config.loading_animation) {
      loadingEl = document.createElement("div");
      loadingEl.className = "live-loading";
      this.container.appendChild(loadingEl);
    }
    if (loadingEl) {
      loadingEl.style.display = "block";
    }
  }

  // 隐藏加载指示器
  hideLoading() {
    const loadingEl = this.container.querySelector(".live-loading");
    if (loadingEl) {
      loadingEl.style.display = "none";
    }
  }

  // 播放视频
  play() {
    if (this.isPlaying) return;

    this.isPlaying = true;
    this.staticImage.style.opacity = 0;
    this.video.classList.add("playing");
    if (this.video.readyState < 3) { // HAVE_FUTURE_DATA
      this.showLoading();
    }

    // 播放视频
    const playPromise = this.video.play();

    if (playPromise !== undefined) {
      playPromise.catch((error) => {
        console.error("视频播放失败:", error);
        this.hideLoading();
        this.isPlaying = false;
      });
    }
  }

  // 停止播放
  stop() {
    this.video.classList.remove("playing");
    this.staticImage.style.opacity = 1;
    this.isPlaying = false;
    this.hideLoading();
  }

  // 自动播放（当进入视口时）
  autoPlay() {
    if (!this.hasAutoPlayed && this.config.autoplay) {
      this.hasAutoPlayed = true;
      this.play();
    }
  }
}

// 页面主控制器
class LivePhotoPage {
  constructor(config) {
    this.config = config;
    this.livePhotos = [];
    this.observer = null;

    this.init();
  }

  // 初始化
  init() {
    this.detectLivePhotos();

    // 检测是否为微信环境
    const isWeixin = navigator.userAgent
      .toLowerCase()
      .includes("micromessenger");

    // 如果在微信环境中且禁用自动播放，则不设置Intersection Observer
    if (isWeixin && this.config.weixin_disable_autoplay) {
      return;
    }

    // 如果启用懒加载，设置Intersection Observer
    if (this.config.lazy_load) {
      this.setupIntersectionObserver();
    } else if (this.config.autoplay) {
      // 如果不使用懒加载，直接自动播放所有
      this.livePhotos.forEach((livePhoto) => livePhoto.autoPlay());
    }
  }

  // 检测页面中的所有Live Photo容器
  detectLivePhotos() {
    const containers = document.querySelectorAll(".live-photo-container");

    containers.forEach((container) => {
      // 检查是否已经初始化过
      if (!container.dataset.initialized) {
        const livePhoto = new LivePhoto(container, this.config);
        this.livePhotos.push(livePhoto);
        container.dataset.initialized = "true";
      }
    });
  }

  // 设置Intersection Observer
  setupIntersectionObserver() {
    // 如果已有observer，先断开所有观察
    if (this.observer) {
      this.observer.disconnect();
    }

    // 创建新的observer
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            // 找到对应的LivePhoto实例
            const container = entry.target;
            const livePhoto = this.livePhotos.find(
              (lp) => lp.container === container
            );

            if (livePhoto) {
              livePhoto.autoPlay();

              // 如果不需要持续观察，可以取消观察
              if (!this.config.keep_observing) {
                this.observer.unobserve(container);
              }
            }
          }
        });
      },
      {
        threshold: this.config.threshold,
        rootMargin: "0px 0px 10% 0px", // 底部提前10%触发
      }
    );

    // 开始观察所有Live Photo容器
    this.livePhotos.forEach((livePhoto) => {
      this.observer.observe(livePhoto.container);
    });
  }
}

// 当DOM加载完成后初始化
document.addEventListener("DOMContentLoaded", function () {
  if (window.LivePhotoConfig && window.LivePhotoConfig.enable) {
    window.livePhotoPage = new LivePhotoPage(window.LivePhotoConfig);
  }
});
</script><!-- hexo injector body_end end --></body>
</html>
